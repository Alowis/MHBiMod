if(vtau<0)q0=0.9
qq<-c()
cm<-c()
cq<-c()
ccd<-c()
qc<-.95
rq0<-seq(0.75,0.95,by=0.01)
for(q0 in rq0){
estims<-try(BveLTDep (data= kk,mod.thresh.u = q0,crit.lev.u = qc,sig.lev=0.05,ci.meth='pl',marg.inf=T),silent = T)
qd<-try((estims$par[2]),silent=T)
cd<-try((estims$chiCIs),silent=T)
cc<-try((estims$chi),silent=T)
if(is.numeric(qd)){
qq<-c(qq,qd)
ccd<-c(ccd,cc)
}
if(is.numeric(cd)){
cq<-c(cq,cd)
}
}
plot(ccd)
plot(qq)
sumd<-0
for(i in 1:length(diff(qq))){
sdiff<-diff(qq)[i]
sumd<-c(sumd,sumd[i]+sdiff)}
sh<-which(sumd<=-0.02|sumd>=0.02 )[1]
q0<-rq0[sh-1]
plot(sumd)
estims<-try(BveLTDep (data= kk,mod.thresh.u = q0,crit.lev.u = qc,sig.lev=0.05,ci.meth='se',marg.inf=T),silent = T)
chat=NA
etahat=NA
Chilow=NA
Chimed=NA
try(chat<-estims$par[1],silent=T)
try(etahat<-estims$par[2],silent=T)
try(Chilow<-estims$chiCIs[1],silent=T)
try(Chimed<-estims$chi,silent=T)
#Loop for asymptotic dependence
if (!is.na(Chilow) & (Chilow<0.05 & etahat<0.75| etahat<0.6)){
print("AI")
bet=beta
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^bet
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^bet
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s^(eta1)*wqxFrechet
projy<-s^(eta2)*wqyFrechet
}else{
projx<-s*wqxFrechet
projy<-s*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
if(interh=="casc"){
pobj<-c(seq(0.00000005,0.00005,by=0.0000001),seq(0.00002,pbas/5,by=0.00005))
s=pbas/pobj
wqobjf<-c()
for (sl in 1:length(s)){
if (etahat<0.85& Chilow<0.02){
print("AI")
beta=200
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^beta
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^beta
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s[sl]^(eta1)*wqxFrechet
projy<-s[sl]^(eta2)*wqyFrechet
}else{
# plot(xFrechet,yFrechet)
projx<-s[sl]*wqxFrechet
projy<-s[sl]*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
wqobj<-removeNA(wqobj)
wqobj<-data.frame(wqobj)
wqobj[,1]<-jitter(wqobj[,1])
xlt=seq(min(wqobj[,1]),max(wqobj[,1])-0.1,length.out = 120)
xlto=seq(min(wq0ri[,1]),max(wq0ri[,1])-0.1,length.out = 120)
if(length(wqobj[,1])<102){
repeat{
mirror<-wqobj[c(length(wqobj[,1]):1),]
wqobj<-rbind(wqobj,mirror)
if(length(wqobj[,1])>=102) break
}
wqobj<-round(wqobj,8)
wqobj<-wqobj[order(wqobj[,1],-wqobj[,2]),]
wqobj[,1]<-jitter(wqobj[,1])
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
ltl1<-ltl
ltl2<-ltl
if (pobj[sl]>0.0000001){
gridx<-(seq(min(ltl[,1],na.rm=T),max(mar1),length.out=100))
gridy<-(seq(min(ltl[,2],na.rm=T),max(mar2),length.out=100))
ltl1[,1]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$x
ltl1[,2]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$y
ltl2[,1]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$y
ltl2[,2]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$x
}
ltl1<-data.frame(ltl1,rep(pobj[sl],100),rep(sl,100))
ltl2<-data.frame(ltl2,rep(pobj[sl],100),rep(sl,100))
wqobjf<-rbind(wqobjf,ltl1,ltl2)
}
plot(wqobjf[,1],wqobjf[,2],col=wqobjf[,4])
tg=50
gridx<-seq(min(wqobjf[,1],na.rm=T),max(mar1),length.out=tg)
gridy<-seq(min(wqobjf[,2],na.rm=T),max(mar2),length.out=tg)
pxg<-approx(mar1, px, xout = gridx, method = "linear",yleft = min(px),yright = max(px), rule = 1)$y
pyg<-approx(mar2, py, xout = gridy, method = "linear",yleft = min(py),yright = max(py), rule = 1)$y
matjt<-matrix(ncol=tg,nrow=tg)
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,1]>gridx[k] & wqobjf[,1]<=gridx[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,2]>gridy[j] & wqobjf[colx,2]<=gridy[j+1])]
if(length(coly)==0){matjt[j,k]=NA}else{
matjt[k,j]=mean(coly,na.rm=T)/(1-pxg[k])}
}
}
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,2]>gridy[k] & wqobjf[,2]<=gridy[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,1]>gridx[j] & wqobjf[colx,1]<=gridx[j+1])]
if(length(coly)==0){matjt[j,k]=matjt[j,k]}else{
matjt[j,k]=mean(coly,na.rm=T)/(1-pxg[j])}
}
}
grid <- expand.grid(lon=gridx, lat=gridy)
for (nap in 1: length(pxg)){ matjt[,nap]<-na.approx(matjt[,nap],maxgap = 5,na.rm=F)}
for (nap in 1: length(pxg)){ matjt[nap,]<-na.approx(matjt[nap,],maxgap = 5,na.rm=F)}
levelplot(matjt ~ lon * lat, data=grid, cuts=20, pretty=T,contour=T)
contour(gridx,gridy,matjt,levels=0.001)
sh<-contourLines(gridx,gridy,matjt,levels=upobj)
obx<-c()
oby<-c()
for (ssh in 1:length(sh)){
obx<-c(obx,sh[[ssh]]$x)
oby<-c(oby,sh[[ssh]]$y)
}
plot(obx,oby)
wqobj<-data.frame(obx,oby)
}
res<-list(levelcurve=wqobj,etaJT=etahat,chiJT= Chimed,wq0ri=wq0ri)
}
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=u1b,mar2=u2b,px=pxfp,py=pyfp,interh=interh)
remove.packages("mobirep", lib="~/R/win-library/4.0")
devtools::install_github("Alowis/mobirep")
library(mobirep)
data(porto)
AnalogSel(fire01meantemp)
tr1=0.9
tr2=0.9
fire01meantemp=na.omit(fire01meantemp)
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=u1b,mar2=u2b,px=pxfp,py=pyfp,interh=interh)
marg<-Margins.mod(tr1,tr2,u)
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
Margins.mod<-function(tr1,tr2,u)
{
th1=quantile(u[,1],tr1,na.rm = T)
th2=quantile(u[,2],tr2,na.rm = T)
idr<-u[which(u[,2]>th2),2]
gpdN1<-evm(u[,1],family=gpd,qu=tr1,start=c(1,1))
gpdN2<-evm(u[,2],family=gpd,qu=tr2,start=c(1,1))
id<-seq(1,length(u[,2]))
u3<-cbind(u,id)
parv1n<-gpdN1$par
parv1n[1]<-exp(parv1n[1])
parv2n<-gpdN2$par
parv2n[1]<-exp(parv2n[1])
pxt1<-texmex::pgpd(u[which(u[,1]>th1+1),1], parv1n[1], xi=parv1n[2], u = as.numeric(th1), lower.tail = T, log.p = F)
pxt1=pxt1*(1-tr1)+tr1
pyt1<-texmex::pgpd(u[which(u[,2]>th2+1),2], parv2n[1], xi=parv2n[2], u = as.numeric(th2), lower.tail = T, log.p = F)
pyt1=pyt1*(1-tr2)+tr2
epdata <- apply(u, 2, rank, na.last = "keep")
nasm <- apply(u, 2, function(x) sum(!is.na(x)))
epdata <-  epdata/rep(nasm + 1, each = nrow(epdata))
tooLow1 <- which(u[,1] <= min(u[,1]))
tooLow2 <- which(u[,2] <= min(u[,2]))
epdata[tooLow1,1] <- 0
epdata[tooLow2,2] <- 0
px<-epdata[,1]
tr1<-approx(u[,1], px, xout = th1, method = "linear",yleft = max(px),yright = min(px), rule = 1)$y
py<-epdata[,2]
tr2<-approx(u[,2], py, xout = th2, method = "linear",yleft = max(py),yright = min(py), rule = 1)$y
interw<-1-(1-tr1)*(1+parv1n[2]*((u[which(u[,1]>th1 & u[,1]<=th1+1),1]-th1)/parv1n[1]))^(-1/parv1n[2])
interr<-1-(1-tr2)*(1+parv2n[2]*((u[which(u[,2]>th2 & u[,2]<=th2+1),2]-th2)/parv2n[1]))^(-1/parv2n[2])
ww=seq(0,1,length=length(interw))
wr=seq(0,1,length=length(interr))
empix<-px[which(u[,1]>th1 & u[,1]<=th1+1)]
empiy<-py[which(u[,2]>th2 & u[,2]<=th2+1)]
interdw<-((1-ww)*empix+ww*interw)
interdr<-((1-wr)*empiy+wr*interr)
pxx<-px[-which(u[,1]>th1)]
pyy<-py[-which(u[,2]>th2)]
pxf<-as.numeric(c(pxx,interdw,pxt1))
pyf<-as.numeric(c(pyy,interdr,pyt1))
plot(pyt1)
pxp<-c(seq(0.999,0.999999,by=0.000001))
u1p<-SpatialExtremes::qgpd(pxp, loc=th1, scale=parv1n[1], shape=parv1n[2], lower.tail = T,lambda=tr1)
pyp<-c(seq(0.999,0.999999,by=0.000001))
u2p<-SpatialExtremes::qgpd(pyp, loc=th2, scale=parv2n[1], shape=parv2n[2], lower.tail = TRUE,lambda=tr2)
u1b<-c(u[,1],u1p)
u2b<-c(u[,2],u2p)
pxo<-c(u3[which(u3[,1]<=th1),3],u3[which(u3[,1]>th1 & u3[,1]<=th1+1),3],u3[which(u3[,1]>th1+1),3])
pxf<-pxf[order(pxo)]
px<-px[order(pxo)]
plot(pxf)
pyo<-c(u3[which(u3[,2]<=th2),3],u3[which(u3[,2]>th2 & u3[,2]<=th2+1),3],u3[which(u3[,2]>th2+1),3])
pyf<-pyf[order(pyo)]
plot(pyf)
plot(px[order(px)],pxf[order(pxf)],xlim=c(0.9,1),ylim=c(0.9,1),type="p")
segments(x0=0,y0=0,x1=1,y1=1,col=2)
plot(pxf[order(pxf)])
pxfp<-as.numeric(c(pxf,pxp))
pyfp<-as.numeric(c(pyf,pyp))
plot(pxf,u[,1])
plot(pyf,u[,2])
plot(pxfp,u1b)
plot(pyfp,u2b)
kk<-data.frame(pxf,pyf)
uu<-data.frame(u1b,u2b)
return(list(kk,uu))
}
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
pp=blss[[1]]
uu=blss[[2]]
#' Compute uniform margins with Generalized Pareto Distribution above threshold
#'
#' @param u Two column data frame
#' @param tr1 extreme threshold for first variable
#' @param tr2 extreme threshold for second variable
#' @export
#' @return pseudo observations (uniform margins) with a mixed distribution (empirical below and gpd above a threshold)
Margins.mod<-function(tr1,tr2,u)
{
th1=quantile(u[,1],tr1,na.rm = T)
th2=quantile(u[,2],tr2,na.rm = T)
idr<-u[which(u[,2]>th2),2]
gpdN1<-evm(u[,1],family=gpd,qu=tr1,start=c(1,1))
gpdN2<-evm(u[,2],family=gpd,qu=tr2,start=c(1,1))
id<-seq(1,length(u[,2]))
u3<-cbind(u,id)
parv1n<-gpdN1$par
parv1n[1]<-exp(parv1n[1])
parv2n<-gpdN2$par
parv2n[1]<-exp(parv2n[1])
pxt1<-texmex::pgpd(u[which(u[,1]>th1+1),1], parv1n[1], xi=parv1n[2], u = as.numeric(th1), lower.tail = T, log.p = F)
pxt1=pxt1*(1-tr1)+tr1
pyt1<-texmex::pgpd(u[which(u[,2]>th2+1),2], parv2n[1], xi=parv2n[2], u = as.numeric(th2), lower.tail = T, log.p = F)
pyt1=pyt1*(1-tr2)+tr2
epdata <- apply(u, 2, rank, na.last = "keep")
nasm <- apply(u, 2, function(x) sum(!is.na(x)))
epdata <-  epdata/rep(nasm + 1, each = nrow(epdata))
tooLow1 <- which(u[,1] <= min(u[,1]))
tooLow2 <- which(u[,2] <= min(u[,2]))
epdata[tooLow1,1] <- 0
epdata[tooLow2,2] <- 0
px<-epdata[,1]
tr1<-approx(u[,1], px, xout = th1, method = "linear",yleft = max(px),yright = min(px), rule = 1)$y
py<-epdata[,2]
tr2<-approx(u[,2], py, xout = th2, method = "linear",yleft = max(py),yright = min(py), rule = 1)$y
interw<-1-(1-tr1)*(1+parv1n[2]*((u[which(u[,1]>th1 & u[,1]<=th1+1),1]-th1)/parv1n[1]))^(-1/parv1n[2])
interr<-1-(1-tr2)*(1+parv2n[2]*((u[which(u[,2]>th2 & u[,2]<=th2+1),2]-th2)/parv2n[1]))^(-1/parv2n[2])
ww=seq(0,1,length=length(interw))
wr=seq(0,1,length=length(interr))
empix<-px[which(u[,1]>th1 & u[,1]<=th1+1)]
empiy<-py[which(u[,2]>th2 & u[,2]<=th2+1)]
interdw<-((1-ww)*empix+ww*interw)
interdr<-((1-wr)*empiy+wr*interr)
pxx<-px[-which(u[,1]>th1)]
pyy<-py[-which(u[,2]>th2)]
pxf<-as.numeric(c(pxx,interdw,pxt1))
pyf<-as.numeric(c(pyy,interdr,pyt1))
plot(pyt1)
pxp<-c(seq(0.999,0.999999,by=0.000001))
u1p<-SpatialExtremes::qgpd(pxp, loc=th1, scale=parv1n[1], shape=parv1n[2], lower.tail = T,lambda=tr1)
pyp<-c(seq(0.999,0.999999,by=0.000001))
u2p<-SpatialExtremes::qgpd(pyp, loc=th2, scale=parv2n[1], shape=parv2n[2], lower.tail = TRUE,lambda=tr2)
u1b<-c(u[,1],u1p)
u2b<-c(u[,2],u2p)
pxo<-c(u3[which(u3[,1]<=th1),3],u3[which(u3[,1]>th1 & u3[,1]<=th1+1),3],u3[which(u3[,1]>th1+1),3])
pxf<-pxf[order(pxo)]
px<-px[order(pxo)]
plot(pxf)
pyo<-c(u3[which(u3[,2]<=th2),3],u3[which(u3[,2]>th2 & u3[,2]<=th2+1),3],u3[which(u3[,2]>th2+1),3])
pyf<-pyf[order(pyo)]
plot(pyf)
plot(px[order(px)],pxf[order(pxf)],xlim=c(0.9,1),ylim=c(0.9,1),type="p")
segments(x0=0,y0=0,x1=1,y1=1,col=2)
plot(pxf[order(pxf)])
pxfp<-as.numeric(c(pxf,pxp))
pyfp<-as.numeric(c(pyf,pyp))
plot(pxf,u[,1])
plot(pyf,u[,2])
plot(pxfp,u1b)
plot(pyfp,u2b)
kk<-data.frame(pxfp,pyfp)
uu<-data.frame(u1b,u2b)
return(list(kk,uu))
}
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
pp=blss[[1]]
uu=blss[[2]]
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
pp=blss[[1]]
uu=blss[[2]]
vtau<-cor.test(x=fire01meantemp[,1],y=fire01meantemp[,2],method="kendall")$estimate
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
upobj=0.001
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
JT.KDE.ap<-function(u2,pbas ,pobj,beta,vtau,devplot=F,mar1,mar2,px,py,interh=NA){
e1<-seq(0,1.2*max(u2[,1]),length.out=200)
e2<-seq(0,1.2*max(u2[,2]),length.out=200)
evp<-as.data.frame(cbind(e1,e2))
bwaa=expand.grid(e1,e2)
aa<-kcde(u2, gridsize=300,tail.flag = "upper.tail",xmin=c(0,0),xmax=c(1.5*max(u2[,1]),1.5*max(u2[,2])))
lox<-aa$eval.points[[1]]
loy<-aa$eval.points[[2]]
ngx=100000
godx<-approx(mar1,px, n = ngx, method = "linear",
yleft = min(px), yright = max(px))
gody<-approx(mar2,py, n = ngx, method = "linear",
yleft = min(py), yright = max(py))
pxe<-approx(godx$x, godx$y, xout = lox, method = "linear",yleft = min(px),yright = max(px), rule = 1)$y
pye<-approx(gody$x, gody$y, xout = loy, method = "linear",yleft = min(py),yright = max(py), rule = 1)$y
if(devplot==T){
plot(aa,cont = c(0.05,0.1),display="filled.contour" ,col=viridis(10))
}
az<-aa$estimate
wq<-contourLines(lox,loy, az, levels = c(0.7,0.5,0.2,0.1,pbas))
wq0ri<-cbind(wq[[5]]$x,wq[[5]]$y)
var1<-u2[,1]
var2<-u2[,2]
wu<-data.frame(u2)
ovar1<-var1[order(var1)]
rx1<-rank(ovar1)
ovar2<-var2[order(var2)]
rx2<-rank(ovar2)
p01=0.01
p02=0.01
q0=0.92
if(length(which(wq0ri[,1]<0))>0)wq0ri<-wq0ri[-which(wq0ri[,1]<0),]
if(length(which(wq0ri[,2]<0))>0)wq0ri<-wq0ri[-which(wq0ri[,2]<0),]
wqUnitx<- approx(mar1, px, xout = wq0ri[,1], method = "linear",yleft = min(px),yright = max(px), rule = 1)$y
wqUnity<- approx(mar2, py, xout = wq0ri[,2], method = "linear",yleft = min(py),yright = max(py), rule = 1)$y
#Transforming Pbase to Frechet Margins
wqxFrechet<--1/log(wqUnitx)
wqyFrechet<--1/log(wqUnity)
pb<-1-pbas
#Setting up Pobjective
s=pbas/pobj
xFrechet<--1/log(px)
yFrechet<--1/log(py)
# ModelHugo_file=paste0(getwd(),"/LF/BveLTDep.R")
# source (ModelHugo_file)
if(vtau<0)q0=0.9
qq<-c()
cm<-c()
cq<-c()
ccd<-c()
qc<-.95
rq0<-seq(0.75,0.95,by=0.01)
for(q0 in rq0){
estims<-try(Bv.LT.Dep (data= kk,mod.thresh.u = q0,crit.lev.u = qc,sig.lev=0.05,ci.meth='pl',marg.inf=T),silent = T)
qd<-try((estims$par[2]),silent=T)
cd<-try((estims$chiCIs),silent=T)
cc<-try((estims$chi),silent=T)
if(is.numeric(qd)){
qq<-c(qq,qd)
ccd<-c(ccd,cc)
}
if(is.numeric(cd)){
cq<-c(cq,cd)
}
}
plot(ccd)
plot(qq)
sumd<-0
for(i in 1:length(diff(qq))){
sdiff<-diff(qq)[i]
sumd<-c(sumd,sumd[i]+sdiff)}
sh<-which(sumd<=-0.02|sumd>=0.02 )[1]
q0<-rq0[sh-1]
plot(sumd)
estims<-try(BveLTDep (data= kk,mod.thresh.u = q0,crit.lev.u = qc,sig.lev=0.05,ci.meth='se',marg.inf=T),silent = T)
chat=NA
etahat=NA
Chilow=NA
Chimed=NA
try(chat<-estims$par[1],silent=T)
try(etahat<-estims$par[2],silent=T)
try(Chilow<-estims$chiCIs[1],silent=T)
try(Chimed<-estims$chi,silent=T)
#Loop for asymptotic dependence
if (!is.na(Chilow) & (Chilow<0.05 & etahat<0.75| etahat<0.6)){
print("AI")
bet=beta
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^bet
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^bet
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s^(eta1)*wqxFrechet
projy<-s^(eta2)*wqyFrechet
}else{
projx<-s*wqxFrechet
projy<-s*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
if(interh=="casc"){
pobj<-c(seq(0.00000005,0.00005,by=0.0000001),seq(0.00002,pbas/5,by=0.00005))
s=pbas/pobj
wqobjf<-c()
for (sl in 1:length(s)){
if (etahat<0.85& Chilow<0.02){
print("AI")
beta=200
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^beta
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^beta
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s[sl]^(eta1)*wqxFrechet
projy<-s[sl]^(eta2)*wqyFrechet
}else{
# plot(xFrechet,yFrechet)
projx<-s[sl]*wqxFrechet
projy<-s[sl]*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
wqobj<-removeNA(wqobj)
wqobj<-data.frame(wqobj)
wqobj[,1]<-jitter(wqobj[,1])
xlt=seq(min(wqobj[,1]),max(wqobj[,1])-0.1,length.out = 120)
xlto=seq(min(wq0ri[,1]),max(wq0ri[,1])-0.1,length.out = 120)
if(length(wqobj[,1])<102){
repeat{
mirror<-wqobj[c(length(wqobj[,1]):1),]
wqobj<-rbind(wqobj,mirror)
if(length(wqobj[,1])>=102) break
}
wqobj<-round(wqobj,8)
wqobj<-wqobj[order(wqobj[,1],-wqobj[,2]),]
wqobj[,1]<-jitter(wqobj[,1])
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
ltl1<-ltl
ltl2<-ltl
if (pobj[sl]>0.0000001){
gridx<-(seq(min(ltl[,1],na.rm=T),max(mar1),length.out=100))
gridy<-(seq(min(ltl[,2],na.rm=T),max(mar2),length.out=100))
ltl1[,1]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$x
ltl1[,2]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$y
ltl2[,1]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$y
ltl2[,2]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$x
}
ltl1<-data.frame(ltl1,rep(pobj[sl],100),rep(sl,100))
ltl2<-data.frame(ltl2,rep(pobj[sl],100),rep(sl,100))
wqobjf<-rbind(wqobjf,ltl1,ltl2)
}
plot(wqobjf[,1],wqobjf[,2],col=wqobjf[,4])
tg=50
gridx<-seq(min(wqobjf[,1],na.rm=T),max(mar1),length.out=tg)
gridy<-seq(min(wqobjf[,2],na.rm=T),max(mar2),length.out=tg)
pxg<-approx(mar1, px, xout = gridx, method = "linear",yleft = min(px),yright = max(px), rule = 1)$y
pyg<-approx(mar2, py, xout = gridy, method = "linear",yleft = min(py),yright = max(py), rule = 1)$y
matjt<-matrix(ncol=tg,nrow=tg)
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,1]>gridx[k] & wqobjf[,1]<=gridx[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,2]>gridy[j] & wqobjf[colx,2]<=gridy[j+1])]
if(length(coly)==0){matjt[j,k]=NA}else{
matjt[k,j]=mean(coly,na.rm=T)/(1-pxg[k])}
}
}
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,2]>gridy[k] & wqobjf[,2]<=gridy[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,1]>gridx[j] & wqobjf[colx,1]<=gridx[j+1])]
if(length(coly)==0){matjt[j,k]=matjt[j,k]}else{
matjt[j,k]=mean(coly,na.rm=T)/(1-pxg[j])}
}
}
grid <- expand.grid(lon=gridx, lat=gridy)
for (nap in 1: length(pxg)){ matjt[,nap]<-na.approx(matjt[,nap],maxgap = 5,na.rm=F)}
for (nap in 1: length(pxg)){ matjt[nap,]<-na.approx(matjt[nap,],maxgap = 5,na.rm=F)}
levelplot(matjt ~ lon * lat, data=grid, cuts=20, pretty=T,contour=T)
contour(gridx,gridy,matjt,levels=0.001)
sh<-contourLines(gridx,gridy,matjt,levels=upobj)
obx<-c()
oby<-c()
for (ssh in 1:length(sh)){
obx<-c(obx,sh[[ssh]]$x)
oby<-c(oby,sh[[ssh]]$y)
}
plot(obx,oby)
wqobj<-data.frame(obx,oby)
}
res<-list(levelcurve=wqobj,etaJT=etahat,chiJT= Chimed,wq0ri=wq0ri)
}
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
