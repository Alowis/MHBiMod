try(etahat<-estims$par[2],silent=T)
try(Chilow<-estims$chiCIs[1],silent=T)
try(Chimed<-estims$chi,silent=T)
#Loop for asymptotic dependence
if (!is.na(Chilow) & (Chilow<0.05 & etahat<0.75| etahat<0.6)){
print("AI")
bet=beta
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^bet
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^bet
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s^(eta1)*wqxFrechet
projy<-s^(eta2)*wqyFrechet
}else{
projx<-s*wqxFrechet
projy<-s*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
if(interh=="casc"){
pobj<-c(seq(0.00000005,0.00005,by=0.0000001),seq(0.00002,pbas/5,by=0.00005))
s=pbas/pobj
wqobjf<-c()
for (sl in 1:length(s)){
if (etahat<0.85& Chilow<0.02){
print("AI")
beta=200
m1= 1- (wqxFrechet/(wqxFrechet+wqyFrechet))^beta
m2<-1- (wqyFrechet/(wqxFrechet+wqyFrechet))^beta
eta1<-m1*etahat + (1-m1)
eta2<-m2*etahat + (1-m2)
projx<-s[sl]^(eta1)*wqxFrechet
projy<-s[sl]^(eta2)*wqyFrechet
}else{
# plot(xFrechet,yFrechet)
projx<-s[sl]*wqxFrechet
projy<-s[sl]*wqyFrechet}
projbackx<-exp(-(1/projx))
projbacky<-exp(-(1/projy))
objx<-approx(px,mar1, xout = projbackx, method = "linear",yleft = min(mar1),yright = max(mar1), rule = 1)$y
objy<-approx(py,mar2, xout = projbacky, method = "linear",yleft = min(mar2),yright = max(mar2), rule = 1)$y
wqobj<-cbind(objx, objy)
wqobj<-removeNA(wqobj)
wqobj<-data.frame(wqobj)
wqobj[,1]<-jitter(wqobj[,1])
xlt=seq(min(wqobj[,1]),max(wqobj[,1])-0.1,length.out = 120)
xlto=seq(min(wq0ri[,1]),max(wq0ri[,1])-0.1,length.out = 120)
if(length(wqobj[,1])<102){
repeat{
mirror<-wqobj[c(length(wqobj[,1]):1),]
wqobj<-rbind(wqobj,mirror)
if(length(wqobj[,1])>=102) break
}
wqobj<-round(wqobj,8)
wqobj<-wqobj[order(wqobj[,1],-wqobj[,2]),]
wqobj[,1]<-jitter(wqobj[,1])
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
ltl1<-ltl
ltl2<-ltl
if (pobj[sl]>0.0000001){
gridx<-(seq(min(ltl[,1],na.rm=T),max(mar1),length.out=100))
gridy<-(seq(min(ltl[,2],na.rm=T),max(mar2),length.out=100))
ltl1[,1]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$x
ltl1[,2]<-approx(ltl[,1], ltl[,2], xout = gridx, method = "linear", rule = 1)$y
ltl2[,1]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$y
ltl2[,2]<-approx(ltl[,2], ltl[,1], xout = gridy, method = "linear", rule = 1)$x
}
ltl1<-data.frame(ltl1,rep(pobj[sl],100),rep(sl,100))
ltl2<-data.frame(ltl2,rep(pobj[sl],100),rep(sl,100))
wqobjf<-rbind(wqobjf,ltl1,ltl2)
}
plot(wqobjf[,1],wqobjf[,2],col=wqobjf[,4])
tg=50
gridx<-seq(min(wqobjf[,1],na.rm=T),max(mar1),length.out=tg)
gridy<-seq(min(wqobjf[,2],na.rm=T),max(mar2),length.out=tg)
pxg<-approx(mar1, px, xout = gridx, method = "linear",yleft = min(px),yright = max(px), rule = 1)$y
pyg<-approx(mar2, py, xout = gridy, method = "linear",yleft = min(py),yright = max(py), rule = 1)$y
matjt<-matrix(ncol=tg,nrow=tg)
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,1]>gridx[k] & wqobjf[,1]<=gridx[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,2]>gridy[j] & wqobjf[colx,2]<=gridy[j+1])]
if(length(coly)==0){matjt[j,k]=NA}else{
matjt[k,j]=mean(coly,na.rm=T)/(1-pxg[k])}
}
}
for (k in 1:(length(pxg)-1)){
colx<-which(wqobjf[,2]>gridy[k] & wqobjf[,2]<=gridy[k+1])
for (j in 1:(length(pyg)-1)){
coly<-wqobjf[colx,3][which(wqobjf[colx,1]>gridx[j] & wqobjf[colx,1]<=gridx[j+1])]
if(length(coly)==0){matjt[j,k]=matjt[j,k]}else{
matjt[j,k]=mean(coly,na.rm=T)/(1-pxg[j])}
}
}
grid <- expand.grid(lon=gridx, lat=gridy)
for (nap in 1: length(pxg)){ matjt[,nap]<-na.approx(matjt[,nap],maxgap = 5,na.rm=F)}
for (nap in 1: length(pxg)){ matjt[nap,]<-na.approx(matjt[nap,],maxgap = 5,na.rm=F)}
levelplot(matjt ~ lon * lat, data=grid, cuts=20, pretty=T,contour=T)
contour(gridx,gridy,matjt,levels=0.001)
sh<-contourLines(gridx,gridy,matjt,levels=upobj)
obx<-c()
oby<-c()
for (ssh in 1:length(sh)){
obx<-c(obx,sh[[ssh]]$x)
oby<-c(oby,sh[[ssh]]$y)
}
plot(obx,oby)
wqobj<-data.frame(obx,oby)
}
res<-list(levelcurve=wqobj,etaJT=etahat,chiJT= Chimed,wq0ri=wq0ri)
}
jtres<-JT.KDE.ap(u2=fire01meantemp,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
data(porto)
AnalogSel(fire01meantemp)
tr1=0.9
tr2=0.9
fire01meantemp=na.omit(fire01meantemp)
u=fire01meantemp
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
pp=blss$uvar_ext
uu=blss$val_ext
kk=blss$uvar
interh<-"casc" #"comb or "casc"
upobj=0.001
vtau<-cor.test(x=fire01meantemp[,1],y=fire01meantemp[,2],method="kendall")$estimate
library(mobirep)
devtools::install_github("Alowis/mobirep")
library(mobirep)
data(porto)
AnalogSel(fire01meantemp)
tr1=0.9
tr2=0.9
fire01meantemp=na.omit(fire01meantemp)
u=fire01meantemp
blss=Margins.mod(tr1,tr2,u=fire01meantemp)
pp=blss$uvar_ext
uu=blss$val_ext
kk=blss$uvar
interh<-"casc" #"comb or "casc"
upobj=0.001
vtau<-cor.test(x=fire01meantemp[,1],y=fire01meantemp[,2],method="kendall")$estimate
jtres<-JT.KDE.ap(u2=fire01meantemp,pbas=0.01,pobj=upobj,beta=100,kk=kk,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
plot(jtres$levelcurve)
wq0ri=jtres$wq0ri
wqobj<-na.omit(jtres$levelcurve)
wqobj<-data.frame(wqobj)
wq0ri<-jtres$wq0ri
wqobj[,1]=jitter(wqobj[,1])
plot(wqobj)
jtres$etaJT
jtres$chiJT
print("Conditional model fitting")
if(length(u[,1])<5000){pb=0.02;t.sim=0.98}
if(length(u[,1])>=5000){pb=0.01;t.sim=0.99}
condexres<-Cond.mod.ap(u2=fire01meantemp,tr1,tr2,tsim=t.sim,num.sim=10000,pobj=0.001,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
#demo data: temperature and wildfires
data(porto)
Analogs<-AnalogSel(fire01meantemp)
jo=0
#jo = 0, fitting models on original data
if(jo==0){
u2[,2]<-as.numeric(u2[,2])
u2<-data.frame(u2)
u<-u2
}else{
u<-data.frame(ugig[[jo]])
}
u2=fire01meantemp
u2[,2]<-as.numeric(u2[,2])
u2<-data.frame(u2)
u<-u2
##########################################################
##################Marginal distributions#################
##########################################################
tr1=.95
tr2=.95
marg<-Margins.mod(tr1,tr2,u)
u2[,2]<-as.numeric(u2[,2])
u2<-data.frame(u2)
u<-u2
##########################################################
##################Marginal distributions#################
##########################################################
tr1=.95
tr2=.95
marg<-Margins.mod(tr1,tr2,u)
u=na.omit(u)
marg<-Margins.mod(tr1,tr2,u)
if(length(u[,1])<5000){pb=0.02;t.sim=0.98}
if(length(u[,1])>=5000){pb=0.01;t.sim=0.99}
print("Joint tail model fitting")
jtres<-JT_KDEap(u2=u,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,kk=kk,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
plot(jtres$levelcurve)
wq0ri=jtres$wq0ri
wqobj<-removeNA(jtres$levelcurve)
wqobj<-data.frame(wqobj)
wq0ri<-jtres$wq0ri
wqobj[,1]=jitter(wqobj[,1])
plot(wqobj)
jtres$etaJT
jtres$chiJT
wqobj<-na.omit(wqobj)
wqobj<-data.frame(wqobj)
xlt=seq(min(wqobj[,1]),max(wqobj[,1])-0.1,length.out = 120)
xlto=seq(min(wq0ri[,1]),max(wq0ri[,1])-0.1,length.out = 120)
if(length(wqobj[,1])<102){
repeat{
mirror<-wqobj[c(length(wqobj[,1]):1),]
wqobj<-rbind(wqobj,mirror)
if(length(wqobj[,1])>=102) break
}
wqobj<-round(wqobj,8)
wqobj<-wqobj[order(wqobj[,1],-wqobj[,2]),]
wqobj[,1]<-jitter(wqobj[,1])
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
plot(u)
lines(ltl,col=2)
jtres<-JT.KDE.ap(u2=u,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,kk=kk,vtau=vtau,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
jtres<-JT.KDE.ap(u2=u,pb=0.01,pobj=upobj,beta=100,vtau=vtau,devplot=F,kk=kk,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
jtres<-JT.KDE.ap(u2=u,pb=0.01,pobj=upobj,beta=100,vtau=vtau,kk=kk,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
devtools::document()
devtools::document()
jtres<-JT.KDE.ap(u2=u,pb=0.01,pobj=upobj,beta=100,vtau=vtau,kk=kk,devplot=F,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
plot(jtres$levelcurve)
wq0ri=jtres$wq0ri
wqobj<-removeNA(jtres$levelcurve)
wqobj<-data.frame(wqobj)
wq0ri<-jtres$wq0ri
wqobj[,1]=jitter(wqobj[,1])
plot(jtres$levelcurve)
wq0ri=jtres$wq0ri
wqobj<-na.omit(jtres$levelcurve)
wqobj<-data.frame(wqobj)
wq0ri<-jtres$wq0ri
wqobj[,1]=jitter(wqobj[,1])
plot(wqobj)
jtres$etaJT
jtres$chiJT
wqobj<-na.omit(wqobj)
wqobj<-data.frame(wqobj)
xlt=seq(min(wqobj[,1]),max(wqobj[,1])-0.1,length.out = 120)
xlto=seq(min(wq0ri[,1]),max(wq0ri[,1])-0.1,length.out = 120)
if(length(wqobj[,1])<102){
repeat{
mirror<-wqobj[c(length(wqobj[,1]):1),]
wqobj<-rbind(wqobj,mirror)
if(length(wqobj[,1])>=102) break
}
wqobj<-round(wqobj,8)
wqobj<-wqobj[order(wqobj[,1],-wqobj[,2]),]
wqobj[,1]<-jitter(wqobj[,1])
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
plot(u)
lines(ltl,col=2)
print("Conditional model fitting")
condexres<-Cond_modap(u2=u,tr1,tr2,tsim=t.sim,num.sim=10000,pobj=0.001,interh=interh)
condexres<-Cond.mod.ap(u2=u,tr1,tr2,tsim=t.sim,num.sim=10000,pobj=0.001,interh=interh)
condexres<-Cond.mod.ap(u2=u,tr1,tr2,tsim=t.sim,num.sim=10000,pobj=0.001,mar1=uu[,1],mar2=uu[,2],px=pp[,1],py=pp[,2],interh=interh)
jline<-data.frame(condexres$jline)
xht=seq(ceiling(min(jline[,1])),round(max(jline[,1]),2)-0.1,length.out = 120)
cem.dens<-kde(condexres$onlysim ,gridsize = 200)
jt.dens<-kde(u,gridsize = 200)
if(length(wqobj[,1])<102){
idz<-which(diff(wqobj[,1])==0)
zr<-as.matrix(wqobj[idz,])
if(length(zr)>0)wqobj<-wqobj[-idz,]
ltlq=approx(wqobj[,1], wqobj[,2], xout = xlt, method = "linear",yleft = max(wqobj[,2]),yright = min(wqobj[,2]), rule = 1)
ltlq<-cbind(ltlq$x,ltlq$y)
ltlq<-data.frame(rbind(ltlq,zr))
wqobj<-ltlq[order(ltlq[,1]),]
}
if(length(wq0ri[,1])<102){
idz<-which(diff(wq0ri[,1])==0)
zr<-wq0ri[idz,]
if(length(zr)>0)wq0ri<-wq0ri[-idz,]
ltlqo=approx(wq0ri[,1], wq0ri[,2], xout = xlto, method = "linear",yleft = max(wq0ri[,2]),yright = min(wq0ri[,2]), rule = 1)
ltlqo<-cbind(ltlqo$x,ltlqo$y)
ltlqo<-data.frame(rbind(ltlqo,zr))
wq0ri<-ltlqo[order(ltlqo[,1]),]
}
ltl<-digit.curves.p(start=wqobj[1,], curve=as.matrix(wqobj), nPoints=98, closed = FALSE)
ltlo<-digit.curves.p(start=wq0ri[1,], as.matrix(wq0ri), nPoints=98, closed = FALSE)
htl<-digit.curves.p(start=jline[1,], as.matrix(jline), nPoints=98, closed = FALSE)
htl<-densicurvem(cem.dens,htl, tl="h")
ltl<-densicurvem(jt.dens,ltlo, tl="l", ltl)
denslim<-1e-9
htl<-densi.curv.em(cem.dens,htl, tl="h")
ltl<-densi.curv.em(jt.dens,ltlo, tl="l", ltl)
denslim<-1e-9
print("Copula fitting")
print("Copula fitting")
copulas<-list()
copulas[[1]]<-fitCopula(gumbelCopula(),data=marg,method="itau")
library(VineCopula)
library(Metrics)
print("Copula fitting")
copulas<-list()
copulas[[1]]<-fitCopula(gumbelCopula(),data=marg,method="itau")
library(copula)
copulas<-list()
copulas[[1]]<-fitCopula(gumbelCopula(),data=marg,method="itau")
marg
copulas<-list()
copulas[[1]]<-fitCopula(gumbelCopula(),data=marg$uvar,method="itau")
print("one passed")
copulas[[2]]<-fitCopula(normalCopula(),data=marg$uvar,method="itau")
print("one passed")
copulas[[3]]<-fitCopula(fgmCopula(),data=marg$uvar, method="itau")
print("one passed")
copulas[[4]]<-NA
galsh=F
try(copulas[[4]]<-fitCopula(galambosCopula(),data=marg$uvar,method="itau"),silent=T)
if(is.na(copulas[[4]])){copulas[[4]]<-indepCopula()
galsh=T}
print("one passed")
NORMcop <- function(u,v, para=NULL) {
if(length(u) == 1) u <- rep(u, length(v)) # see asCOP() for reasoning of
if(length(v) == 1) v <- rep(v, length(u)) # this "vectorization" hack
return(copula::pCopula(matrix(c(u,v), ncol=2),normalCopula(para)))
}
copbask<-c(GHcop,NORMcop,FGMcop,GLcop)
copbask<-c(GHcop,NORMcop,FGMcop,GLcop)
library(acopula)
library(copBasic)
library(mobirep)
library(VineCopula)
library(Metrics)
library(copula)
copbask<-c(GHcop,NORMcop,FGMcop,GLcop)
clines<-list()
for (v in 1:4){
if( v!=4 | galsh==F){
copulas[[v]]@copula
c1<-copulas[[v]]@estimate
}
if( v==1){o<-gumbelCopula(c1,dim=2)}
if( v==2){o1<-copNormal(parameters=c1,dim=2)
o<-normalCopula(c1,dim=2)}
if( v==3)o<-fgmCopula(c1,dim=2)
if( v==4 & galsh==F)o<-galambosCopula(c1)
if( v==4 & galsh==T)o<-indepCopula(dim=2)
coco<-copbask[[v]]
cl1<-curve.funct.b(pxfp,pyfp,u1b,u2b,u,pos="l",pobje=upobj,ng=100,inter=interh)
cl2<-curve.funct.b(pxfp,pyfp,u1b,u2b,u,pos="m",pobje=upobj,ng=100,inter=interh)
plot(u,xlim=c(0,60),ylim=c(0,300))
points(cl1,col=2,type="o")
points(cl2,col=3,type="o")
points(cl3,col=4,type="o")
cl<-rbind(cl1,cl2,cl3)
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
if(length(cl[,1])<102){
repeat{
mirror<-cl[c(length(cl[,1]):1),]
cl<-rbind(cl,mirror)
if(length(cl[,1])>=102) break
}
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
}
cli<-digit.curves.p(start=c(cl[1,1],cl[1,2]), as.matrix(cl), nPoints=98, closed = FALSE)
cli<-densicurvcop(cli,o)
clines<-c(clines,list(cli))
}
cl1<-curve.funct.b(pxfp,pyfp,u1b,u2b,u,pos="l",pobje=upobj,ng=100,inter=interh)
cl1<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],u,pos="l",pobje=upobj,ng=100,inter=interh)
cl1<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="l",pobje=upobj,ng=100,inter=interh)
curve.funct.b<-function(pxf,pyf,mar1,mar2,pos,pobje,ng=100,inter="comb"){
if(pos=="l"){
xmin=0
xmax=0.99
ymin=0.99
ymax=1
}
if(pos=="m"){
xmin=0.98
xmax=1
ymin=0.98
ymax=1
}
if(pos=="r"){
xmin=0.99
xmax=1
ymin=0
ymax=0.99
}
ngx=10000
godx<-spline(pxf,mar1, n = ngx, method = "natural",
xmin = xmin, xmax = xmax, ties = mean)
gody<-spline(pyf,mar2, n = ngx, method = "natural",
xmin = ymin, xmax = ymax, ties = mean)
coxi<-approx(godx$y,godx$x, n = ng, method = "linear",
yleft = 0, yright = 1, ties = mean)
coyi<-approx(gody$y,gody$x, n = ng, method = "linear",
yleft = 0, yright = 1, ties = mean)
plot(coxi$x,coxi$y)
godx<-coxi$y
gody<-coyi$y
coxi<-coxi$x
coyi<-coyi$x
repeat{
idx<-which(diff(coxi)<=0)
# print("cl")
if(length(idx)<1){
break
}
coxi[idx+1]=coxi[idx]+0.001
}
repeat{
idy<-which(diff(coyi)<=0)
if(length(idy)<1){
break
}
coyi[idy+1]=coyi[idy]+0.001
}
acp3<-matrix(NA, nrow = ng, ncol = ng)
for (k in 1:length(gody)){
for (j in 1:length(godx)){
if (inter=="comb"){
acp3[j,k]=surfuncCOP(godx[j], gody[k], cop=coco, para=c1)}
if (inter=="casc"){
acp3[j,k]= surfuncCOP(godx[j], gody[k], cop=coco, para=c1)/(1-godx[j])}
}
}
grid <- expand.grid(lon=godx, lat=gody)
levelplot(acp3 ~ lon * lat, data=grid, cuts=20, pretty=T)
cl2<-contourLines(coxi,coyi, acp3, levels = pobje)
if(length(cl2)>0){
cl2<-as.matrix(data.frame(cl2[[1]]$x,cl2[[1]]$y))} else{cl2<-NA}
}
source('~/Package_mobirep/mobirep/R/level_curves.R')
cl1<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="l",pobje=upobj,ng=100,inter=interh)
cl2<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="m",pobje=upobj,ng=100,inter=interh)
plot(u,xlim=c(0,60),ylim=c(0,300))
points(cl1,col=2,type="o")
points(cl2,col=3,type="o")
points(cl3,col=4,type="o")
cl<-rbind(cl1,cl2,cl3)
cl<-round(cl,8)
cl3<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="r",pobje=upobj,ng=100,inter=interh)
plot(u,xlim=c(0,60),ylim=c(0,300))
points(cl1,col=2,type="o")
points(cl2,col=3,type="o")
points(cl3,col=4,type="o")
cl<-rbind(cl1,cl2,cl3)
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
if(length(cl[,1])<102){
repeat{
mirror<-cl[c(length(cl[,1]):1),]
cl<-rbind(cl,mirror)
if(length(cl[,1])>=102) break
}
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
}
cli<-digit.curves.p(start=c(cl[1,1],cl[1,2]), as.matrix(cl), nPoints=98, closed = FALSE)
cli<-densicurvcop(cli,o)
clines<-c(clines,list(cli))
cli<-densi.curv.cop(cli,o)
cli<-densi.curv.cop(cli,o,kk[,1],kk[,2])
source('~/Package_mobirep/mobirep/R/supplement.funct.R')
cli<-densi.curv.cop(cli,o,kk[,1],kk[,2])
clines<-c(clines,list(cli))
clines<-list()
for (v in 1:4){
if( v!=4 | galsh==F){
copulas[[v]]@copula
c1<-copulas[[v]]@estimate
}
if( v==1){o<-gumbelCopula(c1,dim=2)}
if( v==2){o1<-copNormal(parameters=c1,dim=2)
o<-normalCopula(c1,dim=2)}
if( v==3)o<-fgmCopula(c1,dim=2)
if( v==4 & galsh==F)o<-galambosCopula(c1)
if( v==4 & galsh==T)o<-indepCopula(dim=2)
coco<-copbask[[v]]
cl1<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="l",pobje=upobj,ng=100,inter=interh)
cl2<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="m",pobje=upobj,ng=100,inter=interh)
cl3<-curve.funct.b(pp[,1],pp[,2],uu[,1],uu[,2],pos="r",pobje=upobj,ng=100,inter=interh)
plot(u,xlim=c(0,60),ylim=c(0,300))
points(cl1,col=2,type="o")
points(cl2,col=3,type="o")
points(cl3,col=4,type="o")
cl<-rbind(cl1,cl2,cl3)
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
if(length(cl[,1])<102){
repeat{
mirror<-cl[c(length(cl[,1]):1),]
cl<-rbind(cl,mirror)
if(length(cl[,1])>=102) break
}
cl<-round(cl,8)
cl<-cl[order(cl[,1],-cl[,2]),]
cl[,1]<-jitter(cl[,1])
}
cli<-digit.curves.p(start=c(cl[1,1],cl[1,2]), as.matrix(cl), nPoints=98, closed = FALSE)
cli<-densi.curv.cop(cli,o,kk[,1],kk[,2])
clines<-c(clines,list(cli))
}
names(clines)=c("gumbel","normal","fgm","galambos")
